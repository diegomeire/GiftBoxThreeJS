<script src="https://threejs.org/build/three.min.js"></script>
<link rel="stylesheet" type="text/css" href="index.css" >
<div>
    <form id="gui" > Scale
    <input type="range" id="scale" name="Scale" min="50" max="500" value="100"><br>
        
    <br>
    <label for="wrapColor">Choose a ribbon color:</label>
    <select name="wrapColor" id="wrapColor">
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="red">Red</option>
    </select>
        
        
    <br>
    <br>
        
    <label for="ribbonColor">Choose a wrap color:</label>
    <select name="ribbonColor" id="ribbonColor">
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="red">Red</option>
    </select>
        
    </form>
</div>
<div id="subframe">
    <div id="container"></div>
</div>
<!--<script src="main.js" type ="module"></script>-->


<script type="module">

			import * as THREE from './build/three.module.js';
    
			import Stats from './examples/jsm/libs/stats.module.js';

			import { ColladaLoader } from './examples/jsm/loaders/ColladaLoader.js';
			import { OrbitControls } from './examples/jsm/controls/OrbitControls.js';

			var container, stats, clock, controls;
			var camera, scene, renderer, mixer, avatar, CANVAS_WIDTH = 500, CANVAS_HEIGHT = 500;

            var greenWrapGreenRibbon = new THREE.TextureLoader().load( './img/PresentColor0101.png' );
            var greenWrapBlueRibbon = new THREE.TextureLoader().load( './img/PresentColor0102.png' );
            var greenWrapRedRibbon = new THREE.TextureLoader().load( './img/PresentColor0103.png' );
    
            var blueWrapGreenRibbon = new THREE.TextureLoader().load( './img/PresentColor0201.png' );
            var blueWrapBlueRibbon = new THREE.TextureLoader().load( './img/PresentColor0202.png' );
            var blueWrapRedRibbon = new THREE.TextureLoader().load( './img/PresentColor0203.png' );
    
            var redWrapGreenRibbon = new THREE.TextureLoader().load( './img/PresentColor0301.png' );
            var redWrapBlueRibbon = new THREE.TextureLoader().load( './img/PresentColor0302.png' );
            var redWrapRedRibbon = new THREE.TextureLoader().load( './img/PresentColor0303.png' );
    
    
            var roughness = new THREE.TextureLoader().load( './img/PresentRoughness.png');
            var metallic = new THREE.TextureLoader().load( './img/PresentMetallic.png');
            var normal = new THREE.TextureLoader().load( './img/PresentNormal.png');
            
            var textGeo, textMesh1,
                height = 0.001,
				size = .02,
				hover = 0,
				curveSegments = 5,
				bevelThickness = 0.01,
				bevelSize = 0,
				bevelEnabled = false,
				font = undefined,   
                text = "Hello",
                materials = [
					new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
					new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
				];
    
			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 5, CANVAS_HEIGHT/ CANVAS_HEIGHT, 1, 1000 );
				camera.position.set( 1, 1, 1 );

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				// collada

				var loader = new ColladaLoader();
				loader.load( './models/GiftBox.dae', function ( collada ) {
					var animations = collada.animations;
					avatar = collada.scene;
					avatar.traverse( function ( node ) {
						if ( node instanceof THREE.Mesh ) {
							node.frustumCulled = false;
                            node.material = new THREE.MeshPhysicalMaterial( {
                                                        color: greenWrapGreenRibbon, 
                                                        roughness: 1,
                                                        metalness: 1,
                                                        roughnessMap: roughness,
                                                        metalnessMap: metallic,
                                                        normalMap:Â normal
                                                    } );
						}

					} );
//					mixer = new THREE.AnimationMixer( avatar );
//					mixer.clipAction( animations[ 0 ] ).play();
					scene.add( avatar );
				} );
                
                var geometry = new THREE.PlaneGeometry( 0.1, 0.1, 0.1 );
                var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
                var plane = new THREE.Mesh( geometry, material );
                plane.position.set( 0, 0.065, .03444 );
              //  scene.add( plane );
                
                 scene.traverse( function (child) {
                      if ( child instanceof THREE.Mesh ) {
                          console.log( child.name );
                      }
                  });
                
				//

				/*var gridHelper = new THREE.GridHelper( 10, 20 );
				scene.add( gridHelper );
*/
				//

				var ambientLight = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( ambientLight );

				var pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				scene.add( camera );
				camera.add( pointLight );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( CANVAS_WIDTH / CANVAS_HEIGHT );
				renderer.setSize( CANVAS_WIDTH, CANVAS_HEIGHT );//window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.screenSpacePanning = true;
				controls.minDistance = 2;
				controls.maxDistance = 50;
				controls.target.set( 0, 0.07, 0 );
				controls.update();

				//
                loadFont();
                //

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = CANVAS_WIDTH / CANVAS_HEIGHT;
				camera.updateProjectionMatrix();

				renderer.setSize( CANVAS_WIDTH, CANVAS_HEIGHT );

			}
    
    
            function loadFont() {

				var loader = new THREE.FontLoader();
				loader.load( 'fonts/helvetiker_regular.typeface.json', function ( response ) {
					font = response;
                    var geometry = new THREE.TextGeometry( 'Hello three.js!', {
                            font: font,
                            size: 40,
                            height: 5,
                            curveSegments: 12,
                            bevelEnabled: true,
                            bevelThickness: 10,
                            bevelSize: 8,
                            bevelSegments: 5
                        } );
                    
                    var material = new THREE.MeshPhongMaterial( { color: 0x000000} );

                    var mesh = new THREE.Mesh(geometry,material);
                    
                    scene.add( mesh);
				} );

			}
    
    
    
    
        function createText() {

				textGeo = new THREE.TextGeometry( text, {
                                                font: font,
                                                size: size,
                                                height: height,
                                                curveSegments: curveSegments,
                                                bevelThickness: bevelThickness,
                                                bevelSize: bevelSize,
                                                bevelEnabled: bevelEnabled
				} );

				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();

				var triangle = new THREE.Triangle();

				// "fix" side normals by removing z-component of normals for side faces
				// (this doesn't work well for beveled geometry as then we lose nice curvature around z-axis)

				if ( ! bevelEnabled ) {

					var triangleAreaHeuristics = 0.1 * ( height * size );

					for ( var i = 0; i < textGeo.faces.length; i ++ ) {

						var face = textGeo.faces[ i ];

						if ( face.materialIndex == 1 ) {

							for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

								face.vertexNormals[ j ].z = 0;
								face.vertexNormals[ j ].normalize();

							}

							var va = textGeo.vertices[ face.a ];
							var vb = textGeo.vertices[ face.b ];
							var vc = textGeo.vertices[ face.c ];

							var s = triangle.set( va, vb, vc ).getArea();

							if ( s > triangleAreaHeuristics ) {

								for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

									face.vertexNormals[ j ].copy( face.normal );

								}

							}

						}

					}

				}

				var centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				textGeo = new THREE.BufferGeometry().fromGeometry( textGeo );

				textMesh1 = new THREE.Mesh( textGeo, materials );

				textMesh1.position.x = 0;//centerOffset;
				textMesh1.position.y = 0.1;
				textMesh1.position.z = 0.035;

				textMesh1.rotation.x = 0;
				textMesh1.rotation.y = Math.PI * 2;

				scene.add( textMesh1 );


			}


			function animate() {

                var scale = document.getElementById( "scale" ).value / 100;
                scene.traverse( function (child) {
                      if ( child instanceof THREE.Mesh ) {
                          child.scale.x = child.scale.y = child.scale.z = scale;
                          var wrap = document.getElementById("wrapColor").value;
                          var ribbon = document.getElementById("ribbonColor").value;
                          
                          if (wrap == "green" && ribbon == "green"){
                            child.material.map = greenWrapGreenRibbon;
                          }
                          if (wrap == "green" && ribbon == "blue"){
                            child.material.map = greenWrapBlueRibbon;
                          }
                          if (wrap == "green" && ribbon == "red"){
                            child.material.map = greenWrapRedRibbon;
                          }
                          if (wrap == "blue" && ribbon == "green"){
                            child.material.map = blueWrapGreenRibbon;
                          }
                          if (wrap == "blue" && ribbon == "blue"){
                            child.material.map = blueWrapBlueRibbon;
                          }
                          if (wrap == "blue" && ribbon == "red"){
                            child.material.map = blueWrapRedRibbon;
                          }
                          if (wrap == "red" && ribbon == "green"){
                            child.material.map = redWrapGreenRibbon;
                          }
                          if (wrap == "red" && ribbon == "blue"){
                            child.material.map = redWrapBlueRibbon;
                          }
                          if (wrap == "red" && ribbon == "red"){
                            child.material.map = redWrapRedRibbon;
                          }
                          child.material.needsUpdate = true;
                         
                      }
                  });
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				var delta = clock.getDelta();
				if ( mixer !== undefined ) {
                    mixer.update( delta );
                }
				renderer.render( scene, camera );
			}

		</script> 